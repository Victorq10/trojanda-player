package application.core.utils;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import static application.core.config.ApplicationConfigurationPropertiesService.configurationService;

public class DatabaseService {
    public static final DatabaseService databaseService = new DatabaseService();

    private Connection connection;
    public DbHelper dbHelper;

    protected String getConnectionUrl() {
        // Set the db system directory.
        System.setProperty("derby.system.home", configurationService.getDataDir().toString());
        String connectionUrl = "jdbc:derby:derbydb;create=true"; //+ ";user=dbuser;password=dbuserpwd";
        return connectionUrl;
    }

    //language=Derby
    private static final String FOLDERS_CREATE_TABLE_STATEMENT = """
            CREATE TABLE folders (
                ID         BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                Location   VARCHAR(1000),
                FolderSize VARCHAR(50),
                SongCount  INTEGER,
                Parent     BIGINT
            )
            """;

    //language=Derby
    private static final String FOLDER_LOCATION_IDX_CREATE_INDEX_STATEMENT = """
        CREATE INDEX folder_Location_Idx ON Folders (Location)
        """;

    //language=Derby
    private static final String SONDS_CREATE_TABLE_STATEMENT = """
            CREATE TABLE songs (
                ID            BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                Folder        BIGINT NOT NULL,
                TrackNumber   VARCHAR(50),
                Title         VARCHAR(255),
                Artist        VARCHAR(255),
                Performer     VARCHAR(255),     -- AlbumArtist
                Composer      VARCHAR(255),
                Album         VARCHAR(255),
                RecordedYear  VARCHAR(50),      -- Year
                DiscNumber    VARCHAR(50),
                Quality       VARCHAR(50),
                Genre         VARCHAR(255),
                Comment       VARCHAR(3000),
                BPM           VARCHAR(255),
                CoverImage    VARCHAR(3000),    -- Images are saved in the folder CoverImages
                Lyrics        VARCHAR(3000),
                -- file  characteristic
                FileType      VARCHAR(50),      -- mp3, opus, ogg, m4a (mp4, m4v), flac, wma, wav
                FileName      VARCHAR(255),     -- Just file name
                Location      VARCHAR(1000),    -- Location to file
                FileSize      VARCHAR(50),      -- 3.4MB
                Duration      VARCHAR(50),      -- 3:32
                Rating        INTEGER,          -- from 0 to 5
                DateAdded     TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
                LastPlayed    TIMESTAMP,
                PlayCount     INTEGER NOT NULL DEFAULT 0,
                FOREIGN KEY (Folder) REFERENCES FOLDERS(ID)
            )""".replaceAll("\\s*+--.*?\\n", "\n");

    //language=Derby
    private static final String SOND_LOCATION_IDX_CREATE_INDEX_STATEMENT = """
            CREATE INDEX song_Location_Idx ON Songs (Location)
            """;
    //language=Derby
    private static final String SONG_FILETYPE_IDX_CREATE_INDEX_STATEMENT = """
            CREATE INDEX song_FileType_Idx ON Songs (FileType)
            """;

/*
ALTER TABLE APP.SONGS ALTER Comment SET DATA TYPE VARCHAR(3000);
ALTER TABLE APP.SONGS ALTER CoverImage SET DATA TYPE VARCHAR(3000);
*/

    //language=Derby
    private static final String PLAYLIST_CREATE_TABLE_STATEMENT = """
            CREATE TABLE Playlist (
                ID        BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
                NAME      VARCHAR(255)
            )
            """;

    //language=Derby
    private static final String PLAYLISTSONGRELATION_CREATE_TABLE_STATEMENT = """
            CREATE TABLE PlaylistSongRelation (
                ID          BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                source      BIGINT NOT NULL,
                target      BIGINT NOT NULL,
                UNIQUE (source, target),
                FOREIGN KEY (source) REFERENCES Playlist (ID),
                FOREIGN KEY (target) REFERENCES Songs (ID)
            )
            """;


    protected boolean createTablesAndIndexes() {
        boolean createdTables = false;
        String[] dropTables = """
                DROP TABLE "APP"."PLAYLISTSONGRELATION"
                DROP TABLE "APP"."SONGS"
                DROP TABLE "APP"."FOLDERS"
                DROP TABLE "APP"."PLAYLIST"
            """.split("\\n");
        try (Statement statement = getConnection().createStatement()) {
            logMetaDataTables();
            createTableIfNotExists(statement, "FOLDERS", FOLDERS_CREATE_TABLE_STATEMENT);
            createIndexIfNotExists(statement, "FOLDERS", "folder_Location_Idx", FOLDER_LOCATION_IDX_CREATE_INDEX_STATEMENT);

            createTableIfNotExists(statement, "SONGS", SONDS_CREATE_TABLE_STATEMENT);
            createIndexIfNotExists(statement, "SONGS", "song_Location_Idx", SOND_LOCATION_IDX_CREATE_INDEX_STATEMENT);
            createIndexIfNotExists(statement, "SONGS", "song_FileType_Idx", SONG_FILETYPE_IDX_CREATE_INDEX_STATEMENT);

            createTableIfNotExists(statement, "PLAYLIST", PLAYLIST_CREATE_TABLE_STATEMENT);
            createTableIfNotExists(statement, "PLAYLISTSONGRELATION", PLAYLISTSONGRELATION_CREATE_TABLE_STATEMENT);

            createdTables = true;
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
        return createdTables;
    }

    public static DbHelper db() {
        return databaseService.dbHelper;
    }

    protected Connection getConnection() {
        return connection;
    }

    public final void initConnection() throws IOException {
        try {
            connection = DriverManager.getConnection(getConnectionUrl());
            dbHelper = new DbHelper(connection);
        } catch (SQLException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        createTablesAndIndexes();
    }

    //@Override
    public void stop() throws SQLException {
        if (connection != null) {
            connection.close();
        }
    }

    protected void createTableIfNotExists(Statement statement, String tableName, String createTableStatement) throws SQLException {
        if (!this.isTableExists(null, tableName)) {
            statement.execute(createTableStatement);
        }
    }

    protected void createIndexIfNotExists(Statement statement, String tableName, String indexName, String createIndexStatement) throws SQLException {
        if (!this.isIndexExists(null, tableName, indexName)) {
            statement.execute(createIndexStatement);
        }
    }

    protected boolean isTableExists(String schema, String table) throws SQLException {
        return IsTableExistsHelper.isTableExists(connection, schema, table);
    }


    static class IsTableExistsHelper {
        static boolean USE_INFORMATION_SCHEMA_QUERY = false;
        public static boolean isTableExists(Connection connection, String schema, String table) throws SQLException {
            if (USE_INFORMATION_SCHEMA_QUERY) {
                return isTableExists_internalInformationSchema(connection, schema, table);
            }
            return isTableExists_internalMetadata(connection, schema, table);
        }

        private static boolean isTableExists_internalMetadata(Connection connection, String schema, String table) throws SQLException {
            ResultSet tableNames = connection.getMetaData().getTables(null, schema, table, null);
            if (tableNames.next()) {
                return tableNames.getString("TABLE_NAME").equalsIgnoreCase(table);
            }
            return false;

        }

        private static boolean isTableExists_internalInformationSchema(Connection connection, String schema, String table) throws SQLException {
            String sql = String.format("""
                SELECT * FROM INFORMATION_SCHEMA.TABLES as C
                WHERE
                    lower(C.TABLE_SCHEMA)    = '%s'
                    AND lower(C.TABLE_NAME) = '%s'
                """, schema.toLowerCase(), table.toLowerCase());
            Connection con = connection;
            try (PreparedStatement statement = con.prepareStatement(sql)) {
                ResultSet rs = statement.executeQuery();
                if (rs.next()) {
                    return true;
                }
            } catch (SQLException e) {
                e.printStackTrace();
                //throw e;
            }
            return false;
        }
    }

    protected boolean isIndexExists(String schema, String tableName, String indexName) throws SQLException {
        ResultSet tableNames = connection.getMetaData().getIndexInfo(null, schema, tableName, false, false);
        while (tableNames.next()) {
            if (tableNames.getString("INDEX_NAME").equalsIgnoreCase(indexName)) {
                return true;
            }
        }
        return false;
    }

    protected void logMetaDataTables() throws SQLException {
        //ResultSet tableNames = connection.getMetaData().getTables(null, "PUBLIC", "ADDRESS", null);
        ResultSet tables = connection.getMetaData().getTables(null, "APP", null, null);
        System.out.println("————————————————— ALL TABLES —————————————————");
        logRecords(tables);
        tables.close();
        tables = connection.getMetaData().getTables(null, "APP", null, null);
        List<String> tableNames = new ArrayList<>();
        while (tables.next()) {
            tableNames.add(tables.getString("TABLE_NAME"));
        }
        tables.close();
        for (String tableName : tableNames) { //List.of("FOLDERS", "SONGS", "PLAYLIST", "PLAYLISTSONGRELATION")) {
            System.out.println("————————————————— INDEXES FOR '" + tableName + "' TABLE —————————————————");
            try (ResultSet indexes = connection.getMetaData().getIndexInfo(null, null, tableName, false, false)) {
                logRecords(indexes);
            }
        }
    }

    protected void logRecords(ResultSet rs) throws SQLException {
        List<String> skipColumnNames = List.of(
                "REMARKS", "TYPE_CAT", "TYPE_SCHEM", "TYPE_NAME", "SELF_REFERENCING_COL_NAME",
                "REF_GENERATION",
                "TABLE_CAT", "INDEX_QUALIFIER", "CARDINALITY", "PAGES", "FILTER_CONDITION");

        ResultSetMetaData meta = rs.getMetaData();
        int columnCount = meta.getColumnCount();
        List<List<String>> table = new ArrayList<>();
        int[] columnWidth = new int[columnCount + 1];
        boolean[] skip = new boolean[columnCount + 1];
        // resultSet column names
        List<String> row = new ArrayList<>();
        for (int i = 1; i <= columnCount; i++) {
            String value = meta.getColumnName(i);
            skip[i] = skipColumnNames.contains(value);
            if (skip[i]) {
                continue;
            }
            int k = row.size();
            columnWidth[k] = Math.max(columnWidth[k], value == null ? 1 : value.length());
            row.add(value);
        }
        table.add(row);

        // resultSet data
        while (rs.next()) {
            List<String> row1 = new ArrayList<>();
            for (int i = 1; i <= columnCount; i++) {
                if (skip[i]) {
                    continue;
                }
                String value = rs.getString(i);
                int k = row1.size();
                columnWidth[k] = Math.max(columnWidth[k], value == null ? 1 : value.length());
                row1.add(value);
            }
            table.add(row1);
        }
        // output formatted table
        for (List<String> row3 : table) {
            for (int k = 0; k < row3.size(); k++) {
                row3.set(k, formatValue(row3.get(k), columnWidth[k]));
            }
            System.out.println("" + String.join("|", row3) + "");
        }
        System.out.println();
    }

    private String formatValue(String value, int width) {
        StringBuilder sb = new StringBuilder(value == null ? "" : value);
        while (sb.length() < width) {
            sb.append(" ");
        }
        return sb.toString();
    }

    protected void insertRecords() {
        try (Statement statement = getConnection().createStatement()) {
            if (this.isTableExists(null, "ADDRESS")) {
                statement.execute("INSERT INTO ADDRESS (LASTNAME) VALUES('Viktor') ");
                statement.execute("INSERT INTO ADDRESS (LASTNAME) VALUES('Tetjana') ");
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }
}
